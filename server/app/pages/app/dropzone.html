<div
  class="
    py-1
    after:block
    after:h-2
    after:rounded-sm
    [&[data-dragenter]]:after:bg-gradient-to-r
    after:from-sky-700 after:via-sky-400 after:to-sky-700
    last:h-full
  "
  ondragover="
    // Set dragover to trigger dropzone when hovering over child elements
    event.preventDefault();
    if (!this.hasAttribute('data-dragenter')) { // Prevents flickering
      this.setAttribute('data-dragenter', true);
    }
  "
  ondragenter="
    event.preventDefault();
    event.stopPropagation();
    this.setAttribute('data-dragenter', true);
  "
  ondragleave="
    event.stopPropagation();
    this.removeAttribute('data-dragenter');
  "
  ondrop="
    this.removeAttribute('data-dragenter');

    if (![window.taskBeingDragged.previousElementSibling, window.taskBeingDragged.nextElementSibling].includes(this)) {
      const taskDropzone = window.taskBeingDragged.nextElementSibling;
      taskDropzone.parentElement.removeChild(taskDropzone);
      window.taskBeingDragged.parentElement.removeChild(window.taskBeingDragged);

      this.after(this.cloneNode(false));
      this.after(window.taskBeingDragged);

      const data = <%= JSON.stringify(data) %>;
      const newLane = data.lanes.find((lane) => JSON.stringify(lane) === '<%= JSON.stringify(lane) %>');
      const task = window.taskBeingDragged.textContent;
      const oldLane = data.lanes.find((lane) => lane.tasks.includes(task));
      const index = <%= index %>;

      fetch(window.location.pathname, {
        method: 'PUT',
        body: JSON.stringify({
          ...data,
          lanes: data.lanes.map((lane) => {
            if (lane === oldLane) {
              lane = { ...lane, tasks: lane.tasks.filter(t => t !== task) };
            }
            if (lane === newLane) {
              lane = { ...lane, tasks: [...lane.tasks.slice(0, index), task, ...lane.tasks.slice(index + 1)] };
            }
            return lane;
          })
        }),
      });
    }

    window.taskBeingDragged = null;
  "
><%- children %></div>
